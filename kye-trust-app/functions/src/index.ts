import * as functions from "firebase-functions";
import * as admin from "firebase-admin";
import { ethers } from "ethers";

admin.initializeApp();
const db = admin.firestore();

export const updateTrustScore = functions.https.onCall(async (data, context) => {
  // Authentication check (optional but recommended for production)
  if (!context.auth) {
    throw new functions.https.HttpsError(
      "unauthenticated",
      "The function must be called while authenticated."
    );
  }

  const { uid, success } = data;

  if (!uid || typeof success !== "boolean") {
    throw new functions.https.HttpsError(
      "invalid-argument",
      "The function must be called with a user UID and a success boolean."
    );
  }

  const userRef = db.collection("users").doc(uid);

  try {
    const docSnap = await userRef.get();
    if (!docSnap.exists) {
      throw new functions.https.HttpsError(
        "not-found",
        "User profile not found."
      );
    }

    const currentTrustScore = docSnap.data()?.trustScore || 50;
    let newTrustScore = currentTrustScore;

    if (success) {
      newTrustScore = Math.min(100, currentTrustScore + 10);
    } else {
      newTrustScore = Math.max(0, currentTrustScore - 5);
    }

    await userRef.update({ trustScore: newTrustScore });

    return { status: "success", newTrustScore };
  } catch (error) {
    console.error("Error updating trust score:", error);
    throw new functions.https.HttpsError(
      "internal",
      "Failed to update trust score.",
      error
    );
  }
});

export const updateUserProfile = functions.https.onCall(async (data, context) => {
  // Authentication check
  if (!context.auth) {
    throw new functions.https.HttpsError(
      "unauthenticated",
      "The function must be called while authenticated."
    );
  }

  const { uid } = context.auth;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const { displayName, profilePic } = data; // Assuming data contains displayName and profilePic

  if (!displayName && !profilePic) {
    throw new functions.https.HttpsError(
      "invalid-argument",
      "At least displayName or profilePic must be provided."
    );
  }

  const userRef = db.collection("users").doc(uid);

  try {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const updateData: { [key: string]: any } = {};
    if (displayName) updateData.displayName = displayName;
    if (profilePic) updateData.profilePic = profilePic;

    await userRef.set(updateData, { merge: true });

    return { status: "success", message: "User profile updated successfully." };
  } catch (error) {
    console.error("Error updating user profile:", error);
    throw new functions.https.HttpsError(
      "internal",
      "Failed to update user profile.",
      error
    );
  }
});

export const onPaymentCompleted = functions.firestore
  .document("kyes/{kyeId}/payments/{paymentId}")
  .onCreate(async (snap, context) => {
    const paymentData = snap.data();
    const kyeId = context.params.kyeId; // This is the KyeTrust contract address
    const paymentAmount = paymentData.amount; // Assuming paymentData has an 'amount' field

    if (!paymentAmount || typeof paymentAmount !== "number") {
      console.error(
        `Invalid payment amount for kyeId: ${kyeId}, paymentId: ${context.params.paymentId}`
      );
      return null;
    }

    console.log(
      `New payment detected for Kye: ${kyeId}, Amount: ${paymentAmount}`
    );

    try {
      const provider = new ethers.JsonRpcProvider("http://127.0.0.1:8545");
      // !!! WARNING: For development only. DO NOT use a real private key in production.
      // This is the private key for the first account generated by `npx hardhat node`
      // You can find it in the terminal where hardhat node is running.
      const HARDHAT_PRIVATE_KEY = "0xac0974bec39a17e36ba4a6b4d238ff944bac478cfa74144741567283c14d172b"; // Replace with your actual private key if different
      const wallet = new ethers.Wallet(HARDHAT_PRIVATE_KEY, provider);

      // In a real project, you'd import the full ABI from your artifacts
      const KYE_TRUST_ABI = [
        "function confirmPayment(uint256 _amount) public",
        "function getGoalAmount() public view returns (uint256)", // Example for fetching data
      ];

      const kyeContract = new ethers.Contract(kyeId, KYE_TRUST_ABI, wallet);

      // Convert amount to Wei (or appropriate unit for your contract)
      const amountInWei = ethers.parseEther(paymentAmount.toString());

      console.log(
        `Calling confirmPayment on contract ${kyeId} with amount ${paymentAmount} ETH (${amountInWei.toString()} Wei)`
      );

      const tx = await kyeContract.confirmPayment(amountInWei);
      await tx.wait(); // Wait for the transaction to be mined

      console.log(
        `Transaction successful for payment on Kye ${kyeId}. Tx Hash: ${tx.hash}`
      );

      // Optionally, update Firestore with transaction hash or status
      await snap.ref.update({ blockchainTxHash: tx.hash, blockchainConfirmed: true });

      return { status: "success", txHash: tx.hash };
    } catch (error: any) {
      console.error(
        `Error confirming payment on blockchain for Kye ${kyeId}:`,
        error
      );
      // Log the full error object for debugging
      if (error.code) console.error("Ethers error code:", error.code);
      if (error.reason) console.error("Ethers error reason:", error.reason);
      if (error.data) console.error("Ethers error data:", error.data);

      // Optionally, update Firestore with error status
      await snap.ref.update({ blockchainConfirmed: false, blockchainError: error.message });

      return null; // Indicate failure
    }
  });

export const recordKyeDepositTransaction = functions.https.onCall(async (data, context) => {
  // Authentication check
  if (!context.auth) {
    throw new functions.https.HttpsError(
      "unauthenticated",
      "The function must be called while authenticated."
    );
  }

  const { uid } = context.auth;
  const { kyeId, transactionHash, amount, fromAddress, toAddress } = data;

  // Data validation
  if (
    !kyeId ||
    !transactionHash ||
    typeof amount !== "number" ||
    !fromAddress ||
    !toAddress
  ) {
    throw new functions.https.HttpsError(
      "invalid-argument",
      "Missing or invalid transaction data."
    );
  }

  try {
    await db.collection("kyeTransactions").add({
      kyeId,
      userId: uid,
      transactionHash,
      amount,
      fromAddress,
      toAddress,
      timestamp: admin.firestore.FieldValue.serverTimestamp(),
    });

    return { status: "success", message: "Transaction recorded successfully." };
  } catch (error) {
    console.error("Error recording Kye deposit transaction:", error);
    throw new functions.https.HttpsError(
      "internal",
      "Failed to record Kye deposit transaction.",
      error
    );
  }
});
